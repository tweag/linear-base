
{-# LANGUAGE GHC2021 #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ImpredicativeTypes #-}
{-# LANGUAGE LinearTypes #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}
{-# OPTIONS_GHC -ddump-simpl -ddump-to-file -dsuppress-all #-}
{-# OPTIONS_HADDOCK hide #-}

module Compact.Destination.GFill where

-- *****************************************************************************
-- * THIS FILE IS GENERATED BY SCRIPT GFill.hs.py, PLEASE DO NOT EDIT MANUALLY *
-- *****************************************************************************

import Compact.Destination.Internal
import GHC.Generics
import Data.Kind (Type)
import GHC.Exts
import GHC.TypeLits
import Unsafe.Coerce (unsafeCoerceAddr)

class GFill# lCtor (specCtor :: (Meta, [(Meta, Type)])) (a :: Type) where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld -> (# State# RealWorld, GDestsOf specCtor r #)

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ ]) ~ GSpecCtorOf symCtor (Rep a ())
  ) => GFill# lCtor '(metaCtor, '[ ]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, () #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots0# xInRegion bH# bW# s3 of
              (# s4, (#  #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [])
                        (# s5, () #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots1# xInRegion bH# bW# s3 of
              (# s4, (# d0# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#])
                        (# s5, (Dest d0#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots2# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#])
                        (# s5, (Dest d0#, Dest d1#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1),
                         '( 'MetaSel f2 u2 ss2 ds2, t2)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1,
    NotUnpacked ds2
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1),
                                   '( 'MetaSel f2 u2 ss2 ds2, t2)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1, Dest r t2) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots3# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1#, d2# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#, Ptr d2#])
                        (# s5, (Dest d0#, Dest d1#, Dest d2#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1),
                         '( 'MetaSel f2 u2 ss2 ds2, t2),
                         '( 'MetaSel f3 u3 ss3 ds3, t3)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1,
    NotUnpacked ds2,
    NotUnpacked ds3
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1),
                                   '( 'MetaSel f2 u2 ss2 ds2, t2),
                                   '( 'MetaSel f3 u3 ss3 ds3, t3)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1, Dest r t2, Dest r t3) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots4# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1#, d2#, d3# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#, Ptr d2#, Ptr d3#])
                        (# s5, (Dest d0#, Dest d1#, Dest d2#, Dest d3#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1),
                         '( 'MetaSel f2 u2 ss2 ds2, t2),
                         '( 'MetaSel f3 u3 ss3 ds3, t3),
                         '( 'MetaSel f4 u4 ss4 ds4, t4)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1,
    NotUnpacked ds2,
    NotUnpacked ds3,
    NotUnpacked ds4
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1),
                                   '( 'MetaSel f2 u2 ss2 ds2, t2),
                                   '( 'MetaSel f3 u3 ss3 ds3, t3),
                                   '( 'MetaSel f4 u4 ss4 ds4, t4)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1, Dest r t2, Dest r t3, Dest r t4) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots5# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1#, d2#, d3#, d4# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#, Ptr d2#, Ptr d3#, Ptr d4#])
                        (# s5, (Dest d0#, Dest d1#, Dest d2#, Dest d3#, Dest d4#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1),
                         '( 'MetaSel f2 u2 ss2 ds2, t2),
                         '( 'MetaSel f3 u3 ss3 ds3, t3),
                         '( 'MetaSel f4 u4 ss4 ds4, t4),
                         '( 'MetaSel f5 u5 ss5 ds5, t5)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1,
    NotUnpacked ds2,
    NotUnpacked ds3,
    NotUnpacked ds4,
    NotUnpacked ds5
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1),
                                   '( 'MetaSel f2 u2 ss2 ds2, t2),
                                   '( 'MetaSel f3 u3 ss3 ds3, t3),
                                   '( 'MetaSel f4 u4 ss4 ds4, t4),
                                   '( 'MetaSel f5 u5 ss5 ds5, t5)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1, Dest r t2, Dest r t3, Dest r t4, Dest r t5) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots6# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1#, d2#, d3#, d4#, d5# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#, Ptr d2#, Ptr d3#, Ptr d4#, Ptr d5#])
                        (# s5, (Dest d0#, Dest d1#, Dest d2#, Dest d3#, Dest d4#, Dest d5#) #)
  {-# INLINE gFill# #-}

instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                         '( 'MetaSel f1 u1 ss1 ds1, t1),
                         '( 'MetaSel f2 u2 ss2 ds2, t2),
                         '( 'MetaSel f3 u3 ss3 ds3, t3),
                         '( 'MetaSel f4 u4 ss4 ds4, t4),
                         '( 'MetaSel f5 u5 ss5 ds5, t5),
                         '( 'MetaSel f6 u6 ss6 ds6, t6)]) ~ GSpecCtorOf symCtor (Rep a ()),
    NotUnpacked ds0,
    NotUnpacked ds1,
    NotUnpacked ds2,
    NotUnpacked ds3,
    NotUnpacked ds4,
    NotUnpacked ds5,
    NotUnpacked ds6
  ) => GFill# lCtor '(metaCtor, '[ '( 'MetaSel f0 u0 ss0 ds0, t0),
                                   '( 'MetaSel f1 u1 ss1 ds1, t1),
                                   '( 'MetaSel f2 u2 ss2 ds2, t2),
                                   '( 'MetaSel f3 u3 ss3 ds3, t3),
                                   '( 'MetaSel f4 u4 ss4 ds4, t4),
                                   '( 'MetaSel f5 u5 ss5 ds5, t5),
                                   '( 'MetaSel f6 u6 ss6 ds6, t6)]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, (Dest r t0, Dest r t1, Dest r t2, Dest r t3, Dest r t4, Dest r t5, Dest r t6) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots7# xInRegion bH# bW# s3 of
              (# s4, (# d0#, d1#, d2#, d3#, d4#, d5#, d6# #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [Ptr d0#, Ptr d1#, Ptr d2#, Ptr d3#, Ptr d4#, Ptr d5#, Ptr d6#])
                        (# s5, (Dest d0#, Dest d1#, Dest d2#, Dest d3#, Dest d4#, Dest d5#, Dest d6#) #)
  {-# INLINE gFill# #-}

import os

HEADER = """
{-# LANGUAGE GHC2021 #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ImpredicativeTypes #-}
{-# LANGUAGE LinearTypes #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}
{-# OPTIONS_GHC -ddump-simpl -ddump-to-file -dsuppress-all #-}
{-# OPTIONS_HADDOCK hide #-}

module Compact.Destination.GFill where

-- *****************************************************************************
-- * THIS FILE IS GENERATED BY SCRIPT GFill.hs.py, PLEASE DO NOT EDIT MANUALLY *
-- *****************************************************************************

import Compact.Destination.Internal
import GHC.Generics
import Data.Kind (Type)
import GHC.Exts
import GHC.TypeLits
import Unsafe.Coerce (unsafeCoerceAddr)

class GFill# lCtor (specCtor :: (Meta, [(Meta, Type)])) (a :: Type) where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld -> (# State# RealWorld, GDestsOf specCtor r #)
"""

INSTANCE = """
instance (
    Generic a,
    repA ~ Rep a (),
    metaA ~ GDatatypeMetaOf repA,
    Datatype metaA,
    'MetaCons symCtor fix hasSel ~ metaCtor,
    Constructor metaCtor,
    LiftedCtorToSymbol lCtor ~ symCtor,
    'Just '(metaCtor, '[ {meta_fields_constr}]) ~ GSpecCtorOf symCtor (Rep a ()){not_unpacked_constraints}
  ) => GFill# lCtor '(metaCtor, '[ {meta_fields_head}]) a where
  gFill# :: forall (r :: Type). Compact# -> MVar# RealWorld () -> Addr# -> State# RealWorld
         -> (# State# RealWorld, ({ty_dests}) #)
  gFill# c# m# d# s0 =
    case takeMVar# m# s0 of
      (# s1, () #) ->
        case compactAddHollow# c# (unsafeCoerceAddr (reifyInfoTablePtr# (# #) :: InfoTablePtrOf# lCtor)) s1 of
          (# s2, xInRegion, bH#, bW# #) -> case assign# d# xInRegion s2 of
            (# s3, pXInRegion# #) -> case getSlots{n}# xInRegion bH# bW# s3 of
              (# s4, (# {raw_dests} #) #) -> case putMVar# m# () s4 of
                s5 -> putDebugLn#
                        (showFill (Ptr d#) (Ptr pXInRegion#) (conName @metaCtor undefined) [{ptr_dests}])
                        (# s5, ({dest_dests}) #)
  {{-# INLINE gFill# #-}}
"""

PADDING_META_FIELDS_CONSTR = " " * len("    'Just '(metaCtor, '[ ")
PADDING_META_FIELDS_HEAD = " " * len("  ) => GFill# lCtor '(metaCtor, '[ ")

BOUND = 7

script_dir = os.path.dirname(os.path.abspath(__file__))
gfill_path = os.path.join(script_dir, "GFill.hs")

# make write only so we can override if it exists
if os.path.exists(gfill_path):
    os.chmod(gfill_path, 0o644)

with open(gfill_path, "w", encoding="utf-8") as output_file:
    output_file.write(HEADER)
    for n in range(0, BOUND + 1):
        meta_fields_constr = f",\n{PADDING_META_FIELDS_CONSTR}".join(f"'( 'MetaSel f{i} u{i} ss{i} ds{i}, t{i})" for i in range(n))
        not_unpacked_constraints = "".join(f",\n    NotUnpacked ds{i}" for i in range(n))
        meta_fields_head = f",\n{PADDING_META_FIELDS_HEAD}".join(f"'( 'MetaSel f{i} u{i} ss{i} ds{i}, t{i})" for i in range(n))
        ty_dests = ", ".join(f"Dest r t{i}" for i in range(n))
        raw_dests = ", ".join(f"d{i}#" for i in range(n))
        ptr_dests = ", ".join(f"Ptr d{i}#" for i in range(n))
        dest_dests = ", ".join(f"Dest d{i}#" for i in range(n))
        output_file.write(INSTANCE.format(
            n=n,
            meta_fields_constr=meta_fields_constr,
            not_unpacked_constraints=not_unpacked_constraints,
            meta_fields_head=meta_fields_head,
            ty_dests=ty_dests,
            raw_dests=raw_dests,
            ptr_dests=ptr_dests,
            dest_dests=dest_dests
        ))

# make file read-only to prevent accidents
os.chmod(gfill_path, 0o444)